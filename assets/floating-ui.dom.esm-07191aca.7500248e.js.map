{"version":3,"file":"floating-ui.dom.esm-07191aca.7500248e.js","sources":["../../node_modules/@telekom/scale-components/dist/esm/floating-ui.dom.esm-07191aca.js"],"sourcesContent":["function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset && resetCount <= 50) {\n      resetCount++;\n\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]);\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min$1 = Math.min;\nconst max$1 = Math.max;\n\nfunction within(min$1$1, value, max$1$1) {\n  return max$1(min$1$1, min$1(value, max$1$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const alignment = getAlignment(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n\n    if (clientSize === 0) {\n      clientSize = rects.floating[length];\n    }\n\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max); // Make sure that arrow points at the reference\n\n    const alignmentPadding = alignment === 'start' ? paddingObject[minProp] : paddingObject[maxProp];\n    const shouldAddOffset = alignmentPadding > 0 && center !== offset && rects.reference[length] <= rects.floating[length];\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nasync function convertValueToCoords(middlewareArguments, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = middlewareArguments;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y\n      } = middlewareArguments;\n      const diffCoords = await convertValueToCoords(middlewareArguments, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction getUAString() {\n  const uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)\n  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // • Always-visible scrollbar or not\n  // • Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(target));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { arrow as a, computePosition as c, flip as f, offset as o, shift as s };\n"],"names":["getSide","placement","__name","getAlignment","getMainAxisFromPlacement","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","commonY","mainAxis","length","commonAlign","side","isVertical","coords","computePosition$1","config","strategy","middleware","platform","rects","x","y","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","expandPaddingObject","padding","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","elementClientRect","min$1","max$1","within","min$1$1","value","max$1$1","arrow","alignment","arrowDimensions","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","min","max","center","offset","alignmentOffset","hash$1","getOppositePlacement","matched","getAlignmentSides","mainAlignmentSide","hash","getOppositeAlignmentPlacement","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","detectOverflowOptions","fallbackPlacements","placements","overflow","overflows","overflowsData","main","cross","_middlewareData$flip$","_middlewareData$flip2","nextIndex","nextPlacement","resetPlacement","_overflowsData$map$so","d","acc","a","b","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","crossAxis","alignmentAxis","diffCoords","getCrossAxis","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","isWindow","getWindow","node","ownerDocument","getComputedStyle$1","getNodeName","getUAString","uaData","item","isHTMLElement","isElement","isNode","isShadowRoot","OwnElement","isOverflowElement","overflowX","overflowY","isTableElement","isContainingBlock","isFirefox","css","isLayoutViewport","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","win","addVisualOffsets","width","height","getDocumentElement","getNodeScroll","getWindowScrollBarX","isScaled","getRectRelativeToOffsetParent","offsetParent","isOffsetParentAnElement","documentElement","scroll","offsets","offsetRect","getParentNode","getTrueOffsetParent","getContainingBlock","currentNode","getOffsetParent","window","getDimensions","convertOffsetParentRelativeRectToViewportRelativeRect","getViewportRect","html","visualViewport","layoutViewport","getDocumentRect","_element$ownerDocumen","body","getNearestOverflowAncestor","parentNode","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","updatedList","contains","parent","child","rootNode","next","getInnerBoundingClientRect","top","left","getClientRectFromClippingAncestor","clippingParent","getClippingAncestors","clippingAncestors","clipperElement","getClippingRect","firstClippingAncestor","clippingRect","accRect","clippingAncestor","computePosition"],"mappings":"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"}